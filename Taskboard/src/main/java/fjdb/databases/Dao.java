package fjdb.databases;

import fjdb.pnl.Trade;
import fjdb.pnl.TradeId;
import fjdb.util.DateTimeUtil;

import java.sql.*;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Currency;
import java.util.List;

/**
 * Created by francisbostock on 01/10/2017.
 */
public class Dao {

    /*

    Note: opening balance was Â£51,210,66
    setup create method to actually add the trade:
     - dao needs to convert the trade fields into strings.
     - need column object which define the fields in the database, and how to convert the field in the object to the
     value to store in the database, and back again.
       Ideally, a Currency column would be usable for many tables/objects, trades being just one. But how do the currency
       get extract from trade and passed to the column?


     */

    public static void main(String[] args) throws SQLException {
        Dao dao = new Dao();
//        dao.setup();
//        DatabaseConnection.setupDatabase(Lists.newArrayList(dao));
//        dao.create(new Trade("VSUD", LocalDate.of(2017, 9, 25), 550, 47.437, Currency.getInstance("USD"), 1.12));
//        dao.create(new Trade("VMID", LocalDate.of(2017, 10, 2), 330, 31.9152, Currency.getInstance("GBP"), 1.0));
//        dao.create(new Trade("CNA", LocalDate.of(2017, 10, 11), 3000, 179.4717, Currency.getInstance("GBP"), 1.0));
//        dao.create(new Trade("CLLN", LocalDate.of(2017, 10, 26), 6500, 0.4560, Currency.getInstance("GBP"), 1.0));
//        dao.create(new Trade("MERL", LocalDate.of(2017, 10, 30), 550, 3.7342, Currency.getInstance("GBP"), 1.0));

//        DateTimeFormatter.ofPattern("yyyyMMdd").
//dao.setup();

        List<Trade> trades = dao.load();
        for (Trade trade : trades) {
            System.out.println(trade);
        }
//        System.out.println("Done");
        DatabaseConnection.getInstance().shutdown();

    }

    /*
    The Dao will have an interface including a register/setup method which will be used by the machinery to initially set
    up all the databases.
     */


    public Dao() {

    }

    /*
    cash bean, cash id, map of id to beans, beans do not contain id.
    inserting bean, inserts entry in database, automatically inserting id. Loading from database, selecting all from
    db, add to maps before returning.
     */

    public List<Trade> load() {
        List<Trade> trades = new ArrayList<>();
        Statement stmt = null;
        try {
            stmt = DatabaseConnection.getInstance().createStatement();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        ResultSet resultSet = null;
        try {
            resultSet = stmt.executeQuery("SELECT * FROM TRADES");
            while(resultSet.next()) {
                TradeId tradeId = new TradeId(resultSet.getInt(1));
                Date date = resultSet.getDate(3);
                LocalDate tradeDate = DateTimeUtil.date(date);
                Currency currency = Currency.getInstance(resultSet.getString(6));
                Trade trade = new Trade(resultSet.getString(2), tradeDate, resultSet.getDouble(4), resultSet.getDouble(5), currency, resultSet.getDouble(7));
                trades.add(trade);
//                System.out.println(resultSet.getString(1));
            }
            resultSet.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return trades;
    }

    public void setup() {
        try{
            Statement stmt = DatabaseConnection.getInstance().createStatement();
//            stmt.execute("DROP TABLE TASKDB");
            stmt.execute(createDB());
//            stmt.execute("INSERT INTO TASKDB (NAME, NUMTASKS, LATESTID) VALUES ('TASKDBENTRY', 0, -1)");
//            ResultSet resultSet = stmt.executeQuery("SELECT * FROM TRADES");
//            System.out.println(            resultSet.next());
            stmt.close();
        }
        catch(Exception e){
            System.out.println("Exception: " + e);
            e.printStackTrace();
        }

//        try {
//            connection.close();
//        } catch (SQLException e) {
//            e.printStackTrace();
//        }

    }

    public String createDB() {
        return "CREATE TABLE TRADES (ID INT GENERATED BY DEFAULT AS IDENTITY, " + getColumns() + ")";
    }

    private String getColumns() {
        return "INSTRUMENT VARCHAR(256), TRADE_DATE DATE, QUANTITY DOUBLE, PRICE DOUBLE, CURRENCY VARCHAR(3), FIXING DOUBLE";
    }

    private String getColumnLabels() {
        return "INSTRUMENT, TRADE_DATE, QUANTITY, PRICE, CURRENCY, FIXING";
//        return "INSTRUMENT, TRADE_DATE, QUANTITY, PRICE, CURRENCY, FIXING";
    }



    private List<Object> getTradeObjects(Trade trade) {
        ArrayList<Object> list = Lists.newArrayList();
        list.add(trade.getInstrument());
        list.add(trade.getTradeDate());
        list.add(trade.getQuantity());
        list.add(trade.getPrice());
        list.add(trade.getCurrency());
        list.add(trade.getFixing());
        return list;
    }


    public void create(Trade trade) {
        Statement stmt = null;
        try {
            DatabaseConnection.getInstance().setAutoCommit(false);
            stmt = DatabaseConnection.getInstance().createStatement();

            List<Object> tradeObjects = getTradeObjects(trade);
            String insert = "INSERT INTO TRADES (" + getColumnLabels() + ") values (?,?,?,?,?,?)";
            SqlResolver.prepare(insert, tradeObjects);

//            String tradeStr = getTradeString(trade);


//            String tradeStr = "'S&P500 ETF', NULL, 550, 47.437, 'GBP', 1.33";
            //TODO use prepared statements with ? marks, and if necessary handle the wrapping of strings in quotes
//            stmt.execute("INSERT INTO TRADES (" + getColumnLabels() + ") values (" + tradeStr + ")");
            stmt.close();
            DatabaseConnection.getInstance().commit();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }


    public void delete(Trade trade) {

    }

    public void update(Trade trade) {

    }




    private static class SqlResolver {

        public static void prepare(String sql, List<Object> objects) throws SQLException {
            PreparedStatement preparedStatement = DatabaseConnection.getInstance().prepareStatement(sql);
            String content = sql;
            int num = 0;
            int i;
            while( (i = content.indexOf("?")) != -1) {
                num++;
                content = content.substring(i+1, content.length());
            }
            if (num != objects.size()) {
                throw new SQLException(String.format("Statement (%s args) and argument list (%s args) not consistent", num, objects.size()));
            }

            for (int j = 0; j < objects.size(); j++) {
                resolve(preparedStatement, j+1, objects.get(j));
            }
            //TODO for a pure insert query, use execute. For a select query use executeQuery. If we use the latter for an insert, get exception.
            preparedStatement.execute();
        }


        public static void resolve(PreparedStatement statement, int index, Object object) throws SQLException {
            if (object instanceof LocalDate) {
                LocalDate localDate = (LocalDate) object;
                statement.setDate(index, DateTimeUtil.makeDate(localDate));
            } else if (object instanceof Currency){
                    Currency currency = (Currency) object;
                statement.setString(index, currency.getCurrencyCode());
            } else {
                //if all else fails
                statement.setObject(index, object);
            }
        }

    }


}
