package fjdb.databases;

import com.google.common.base.Joiner;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.Lists;
import fjdb.util.SqlUtil;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * A column dao based around a primary id field.
 * @param <T>
 */
public abstract class IdColumnDao<T extends DataItemIF> extends AbstractSqlDao implements DaoIF<T> {

    private final IdColumnGroup<T> columnGroup;
    //TODO access to this needs to be protected (read/write lock?)
    protected final BiMap<DataId, T> idBeanMap = HashBiMap.create();

    public IdColumnDao(DatabaseAccess access, IdColumnGroup<T> columnGroup) {
        super(access);
        this.columnGroup = columnGroup;
    }

    public List<T> load() {
        List<T> dataItems = new ArrayList<>();
        try {
            String selectQuery = "SELECT * FROM " + getTableName();
            dataItems.addAll(doSelect(selectQuery, new ArrayList<>(), handler()));
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return dataItems;
    }

    private ResultHandler<T> handler() {
        return rs -> {
            DataId id = columnGroup.handleId(rs);
            T handle = columnGroup.handle(rs);
            idBeanMap.put(id, handle);
            return handle;
        };
    }

    //TODO 10 July 21: when inserting at a caching layer, we want to lock the table, do the insert, then do a findId to get the id for the item
    //so we can store both the new item and id.

    @Override
    public void insert(T dataItem) {

        try {
            List<Object> tradeObjects = columnGroup.getDataItemObjects(dataItem);
            if (tradeObjects.size() != columnGroup.columnCount()) {
                throw new RuntimeException(String.format("Arguments and columns different size: %s %s", tradeObjects.size(), columnGroup.columnCount()));
            }
            String insert = "INSERT INTO " + getTableName() + " (" + columnGroup.getColumnLabels() + ") values " + SqlUtil.makeQuestionMarks(columnGroup.columnCount());
            doUpdate(insert, tradeObjects);
        } catch (SQLException e) {
            //TODO should propagate the exception
            e.printStackTrace();
        }
    }

    public DataId findId(T dataItem) {
        IdColumn<?> idColumn = columnGroup.idColumn;
        String idColumnName = idColumn.getName();
        List<Object> tradeObjects = columnGroup.getDataItemObjects(dataItem);
        String select = "SELECT " + idColumnName + " FROM " + getTableName() + " WHERE ";
        List<String> columnNames = columnGroup.getColumnNames();
        List<Object> args = Lists.newArrayList();
        select += Joiner.on(" AND ").join(columnNames.stream().map(name->name + "=?").collect(Collectors.toList()));
        for (int i = 0; i < columnNames.size(); i++) {
            String name = columnNames.get(i);
            Object value = tradeObjects.get(i);
//            select += "?=?";
//            args.add(name);
            args.add(value);
        }
        try {
//            columnGroup.idColumn.get()
            List<DataId> ts = doSelect(select, args, new ResultHandler<DataId>() {
                @Override
                public DataId handle(ResultSet rs) throws SQLException {
                    DataId resolve = columnGroup.resolve(idColumn, rs);
                    return resolve;
                }
            });
            if (ts.size() != 1) {
                //TODO replace with warn log output
                System.out.println(String.format("WARNING Found %s entries for %s (%s)", ts.size(), dataItem, ts));
            } else {
                return ts.get(0);
            }
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
        return null;
    }

    @Override
    protected String createTable() {
        String drop = "DROP TABLE " + getTableName() + " IF EXISTS\n ";
            return drop + "CREATE TABLE " + getTableName() + " (ID INT GENERATED BY DEFAULT AS IDENTITY, " + columnGroup.getColumnDeclarations() + ")";
    }

    @Override
    public void update(T dataItem) {
        try {
            List<Object> tradeObjects = columnGroup.getDataItemObjects(dataItem);
            tradeObjects.add(dataItem.getId().getId());
            List<AbstractColumn> columnList = this.columnGroup.columns;
            String sql = "";
            sql += Joiner.on(",").join(columnList.stream().map(col -> col.getName() + " = ?").collect(Collectors.toList()));
            String insert = "UPDATE " + getTableName() + " SET " + sql + " WHERE " + columnGroup.idColumn.getName() + " = ? ";
            doUpdate(insert, tradeObjects);
        } catch (SQLException e) {
            //TODO should propagate the exception
            e.printStackTrace();
        }
    }

    @Override
    public void delete(T dataItem) {
//            TODO
    }


    public IdColumnGroup<T> getColumnGroup() {
        return columnGroup;
    }
}