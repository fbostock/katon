package fjdb.investments;

import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.Lists;
import fjdb.databases.*;
import fjdb.pnl.Trade;
import fjdb.pnl.TradeType;
import fjdb.util.SqlUtil;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Created by francisbostock on 01/10/2017.
 */
public class TradeDao extends AbstractSqlDao implements DaoIF<Trade> {
    private final Columns columns;

    /*

    Note: opening balance was Â£51,210,66
    setup create method to actually add the trade:
     - dao needs to convert the trade fields into strings.
     - need column object which define the fields in the database, and how to convert the field in the object to the
     value to store in the database, and back again.
       Ideally, a Currency column would be usable for many tables/objects, trades being just one. But how do the currency
       get extract from trade and passed to the column?

TODO Calculate minimum exit date for trades, e.g. in Trade object calculate it for one month hence if equity

TODO add a memory/performance monitor to show current mem usage in jvm, and other properties, to get a feel for how
programs' performance change over time with changes in engines etc. If a new change results in sudden increase in mem,
 may want to address that.


 TODO check how to draw custom nodes using GraphicsContext

//TODO make a quandl fetcher


     */

    public static void main(String[] args) throws SQLException {
        TradeDao tradeDao = new TradeDao();
//        dao.setup();
//        DatabaseConnection.setupDatabase(Lists.newArrayList(dao));
//        dao.create(new Trade(TradeType.ETF, "VSUD", LocalDate.of(2017, 9, 25), 550, 47.437, Currency.getInstance("USD"), 1.12));
//        dao.create(new Trade(TradeType.ETF, "VMID", LocalDate.of(2017, 10, 2), 330, 31.9152, Currency.getInstance("GBP"), 1.0));
//        dao.create(new Trade(TradeType.EQUITY, "CNA", LocalDate.of(2017, 10, 11), 3000, 179.4717, Currency.getInstance("GBP"), 1.0));
//        dao.create(new Trade(TradeType.EQUITY, "CLLN", LocalDate.of(2017, 10, 26), 6500, 0.4560, Currency.getInstance("GBP"), 1.0));
//        dao.create(new Trade(TradeType.EQUITY, "MERL", LocalDate.of(2017, 10, 30), 550, 3.7342, Currency.getInstance("GBP"), 1.0));
//        dao.create(new Trade(TradeType.EQUITY, "TEST", LocalDate.of(2017, 11, 12), 550, 3.7342, Currency.getInstance("GBP"), 1.0));
//        dao.create(new Trade(TradeType.EQUITY, "CITY", LocalDate.of(2018, 1, 15), 8400, 59.6, Currency.getInstance("GBP"), 1.0));
//        dao.create(new Trade(TradeType.EQUITY, "BMK", LocalDate.of(2018, 1, 16), 8000, 75.15, Currency.getInstance("GBP"), 1.0));

//        DateTimeFormatter.ofPattern("yyyyMMdd").
//dao.setup();

        List<Trade> trades = tradeDao.load();
        for (Trade trade : trades) {
            System.out.println(trade);
        }
//        System.out.println("Done");
        DatabaseConnection.getInstance().shutdown();

    }

    /*
    The Dao will have an interface including a register/setup method which will be used by the machinery to initially set
    up all the databases.
     */


    public TradeDao() {
        super(DatabaseAccess.TRADE_ACCESS);
        columns = new Columns();
    }

    /*
    cash bean, cash id, map of id to beans, beans do not contain id.
    inserting bean, inserts entry in database, automatically inserting id. Loading from database, selecting all from
    db, add to maps before returning.
     */

    public List<Trade> load() {
        List<Trade> trades = new ArrayList<>();
        try {
            String selectQuery = "SELECT * FROM " + getTableName();
            trades.addAll(doSelect(selectQuery, new ArrayList<>(), columns::handle));
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return trades;
    }


    public String getTableName() {
        return "TRADES";
    }

    @Override
    public String createTable() {
        return createDB();
    }

    //TODO should this be inlined?
    public String createDB() {
        String drop = "DROP TABLE " + getTableName() + " IF EXISTS\n ";
        return drop + "CREATE TABLE " + getTableName() + " (ID INT GENERATED BY DEFAULT AS IDENTITY, " + getColumns() + ")";
    }

    private String getColumns() {
        return "TRADETYPE VARCHAR(32), INSTRUMENT VARCHAR(256), TRADE_DATE DATE, QUANTITY DOUBLE, PRICE DOUBLE, CURRENCY VARCHAR(3), FIXING DOUBLE";
    }

    public void setup() {
        try {
            Statement stmt = DatabaseConnection.getInstance().createStatement();
            stmt.execute(createDB());
            stmt.close();
        } catch (Exception e) {
            System.out.println("Exception: " + e);
            e.printStackTrace();
        }
    }

    private String getColumnLabels() {
        return columns.getColumnLabels();
//        return "INSTRUMENT, TRADE_DATE, QUANTITY, PRICE, CURRENCY, FIXING";
    }


    /*
    perhaps we can register columns with a class to store the object type so we can construct the trader from a map of columns class references


    similar to row columns, we could supply an extractor which extracts an object of type Clazz from an object associated
    with the row definition. Then, for writing to the database, we have a set of classes which we register for a particular
    class type, that will handle the reading and writing for that class type.
    register(Class<T> clazz, RWclass rwClazz)
    where RWClass had a read method and write method
    T read(ResultSet rs, index) {//construct T from rs.getXXX(index)//}
    void write(T obj) {//extract from T such that the result feeds into the read method to generate T}

    So for a Currency Column, we could register a RWClass as above to create the Currency from a 3 char string, then
    we define a Currency Column object with an extractor from Trade: trade.getCurrency(), with the Column object having
    various other properties such as visible, editable etc. for table displays.

     */
    private static class Columns {
        private final List<AbstractColumn> columns = new ArrayList<>();
        private final TradeIdColumn idColumn;
        private final StringColumn instrumentColumn;
        private final CurrencyColumn currencyColumn;
        private final DateColumn tradeDateColumn;
        private final DoubleColumn quantityColumn;
        private final DoubleColumn priceColumn;
        private final DoubleColumn fixingColumn;
        private final Map<AbstractColumn, Integer> columnIntegerMap;
        private final TypeColumn<TradeType> tradetype;

        //TODO pass in the id column in the constructor? Or have a builder which has a setIdColumn method, as well as
        //addColumn method which adds the column to the columnInt map as well as columns list.
        public Columns() {
            idColumn = new TradeIdColumn("id");
            tradetype = new TypeColumn<>(TradeType.class, "TRADETYPE");
            instrumentColumn = new StringColumn("INSTRUMENT");
            tradeDateColumn = new DateColumn("TRADE_DATE");
            quantityColumn = new DoubleColumn("QUANTITY");
            priceColumn = new DoubleColumn("PRICE");
            currencyColumn = new CurrencyColumn("CURRENCY");
            fixingColumn = new DoubleColumn("FIXING");
//            columns.add(idColumn);

            columnIntegerMap = HashBiMap.create();
            columnIntegerMap.put(idColumn, 1);
            addColumn(tradetype).addColumn(instrumentColumn);
            addColumn(tradeDateColumn).addColumn(quantityColumn);
            addColumn(priceColumn).addColumn(currencyColumn);
            addColumn(fixingColumn);
        }

        private Columns addColumn(AbstractColumn column) {
            columns.add(column);
            columnIntegerMap.put(column, columnIntegerMap.size() + 1);
            return this;
        }

        public Trade handle(ResultSet rs) throws SQLException {

            //TODO add index in Columns class to track this
            return new Trade(resolve(idColumn, rs), resolve(tradetype, rs), resolve(instrumentColumn, rs), resolve(tradeDateColumn, rs),
                    resolve(quantityColumn, rs), resolve(priceColumn, rs),
                    resolve(currencyColumn, rs), resolve(fixingColumn, rs));
        }

        private <V> V resolve(AbstractColumn<V, ?> column, ResultSet rs) throws SQLException {
            return column.get(rs, columnIntegerMap.get(column));
        }

        public List<Object> getTradeObjects(Trade trade) {
            ArrayList<Object> list = Lists.newArrayList();
//            list.add(idColumn.dbElement(trade.getId()));
            list.add(tradetype.dbElement(trade.getType()));
            list.add(instrumentColumn.dbElement(trade.getInstrument()));
            list.add(tradeDateColumn.dbElement(trade.getTradeDate()));
            list.add(quantityColumn.dbElement(trade.getQuantity()));
            list.add(priceColumn.dbElement(trade.getPrice()));
            list.add(currencyColumn.dbElement(trade.getCurrency()));
            list.add(fixingColumn.dbElement(trade.getFixing()));
            return list;
        }

        public String getColumnLabels() {
            return Joiner.on(",").join(columns.stream().map(Functions.toStringFunction()::apply).collect(Collectors.toList()));
        }

        public int columnCount() {
            return columns.size();
        }
    }

    public int getColumnCount() {
        return columns.columnCount();
    }

    private List<Object> getTradeObjects(Trade trade) {
        return columns.getTradeObjects(trade);
//        ArrayList<Object> list = Lists.newArrayList();
//        list.add(trade.getInstrument());
//        list.add(trade.getTradeDate());
//        list.add(trade.getQuantity());
//        list.add(trade.getPrice());
//        list.add(trade.getCurrency());
//        list.add(trade.getFixing());
//        return list;
    }

    @Override
    public void insert(Trade trade) {

        try {
            List<Object> tradeObjects = getTradeObjects(trade);
            if (tradeObjects.size() != getColumnCount()) {
                throw new RuntimeException(String.format("Arguments and columns different size: %s %s", tradeObjects.size(), getColumnCount()));
            }
            String insert = "INSERT INTO " + getTableName() + " (" + getColumnLabels() + ") values " + SqlUtil.makeQuestionMarks(getColumnCount());
            doUpdate(insert, tradeObjects);
        } catch (SQLException e) {
            //TODO should propagate the exception
            e.printStackTrace();
        }
    }


    @Override
    public void delete(Trade trade) {
//TODO
    }

    @Override
    public void update(Trade trade) {
        try {
            List<Object> tradeObjects = getTradeObjects(trade);
            tradeObjects.add(trade.getId().getId());
            List<AbstractColumn> columnList = this.columns.columns;
            String sql = "";
            for (AbstractColumn column : columnList) {
                sql = column.getName() + " = ?,";
            }
            String insert = "UPDATE " + getTableName() + " SET (" + sql + ") WHERE " + columns.idColumn.getName() + " = ? ";
            doUpdate(insert, tradeObjects);
        } catch (SQLException e) {
            //TODO should propagate the exception
            e.printStackTrace();
        }
    }


}
